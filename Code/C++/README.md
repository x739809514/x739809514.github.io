# C++å­¦ä¹ ç¬”è®°

# How C++ work

C++ can translate to machine code directly. And in compiler, .cpp file can be translate to a .obj file after compiling, .h file doesnâ€™t be compile. Linkerâ€™s job is wire up functions, it takes .obj file to .exe

There is no file in c++, c++ donâ€™t care of it, all of .cpp file be compiled into .obj. And include<iostream> make file big.

## include

#include just copy code and paste it.

# How linker work

the error â€œLNKâ€ is a kind of link error. 

- First, linker take all the object files generated by the compiler and combine them into a single executable program.
![Untitled](./c++/Untitled.png)

- Second, in addition to being able to link object files, the linker also is capable of linking library files. AÂ **library file**Â is a collection of precompiled code that has been â€œpackaged upâ€ for reuse in other programs.

## link error

if linker can not find a function or there are many same functions, it will have a link error.

for example:

```csharp
//Log.cpp
void Log(const char* message, int a) {
	std::cout << message << std::endl;
}

//main.cpp
void Log(const char* message);
int main() {
	int arr[7] = { 1,2,3,4,5,6,7 };
	int* p;
	p = arr;
	(*p++)++;
	Log("Hello world"); //in this line, linker cannot find a Log(const char*))
	cout << p << endl;
	return 0;
}
```

or

```csharp
//Log.h
void Log(const char* message) {
	std::cout << message << std::endl;
}

//Log.cpp
#include <iostream>
#include "Log.h"

//main.cpp
#include "Log.h" //include just copy and paste
void Log(const char* message);
int main() {
	//1>main.obj : error LNK2005: "void __cdecl Log(char const *)" (?Log@@YAXPBD@Z) å·²ç»åœ¨ Log.obj ä¸­å®šä¹‰
	//1>D:\Aå·¥ä½œåŒº\C++\learn-space\firstCpp\Debug\firstCpp.exe : fatal error LNK1169: æ‰¾åˆ°ä¸€ä¸ªæˆ–å¤šä¸ªå¤šé‡å®šä¹‰çš„ç¬¦å·
	Log("Hello world"); //è¿™é‡Œå°±ä¼šæœ‰link error
	return 0;
}
```

æ­£å¸¸çš„åšæ³•æ˜¯ï¼Œç”¨Log.cppå®šä¹‰å…·ä½“çš„å‡½æ•°ä½“ï¼Œç„¶åå†å¤´æ–‡ä»¶ä¸­å®šä¹‰å¯¹Log.cppä¸­å‡½æ•°çš„å¼•ç”¨ï¼Œç„¶åå†åœ¨å…·ä½“çš„ç±»ä¸­ä½¿ç”¨include<Log.h>

```csharp
//Log.h
#include "Log.h"

//Log.cpp
#include <iostream>
void Log(const char* message) {
	std::cout << message << std::endl;
}

//main.cpp
#include "Log.h"
int main() {
	Log("Hello world"); //è¿™é‡Œå°±ä¼šæœ‰link error
}
```

## Dynamic linker

åŠ¨æ€é“¾æ¥å™¨ï¼ˆDynamic Linkerï¼‰æ˜¯ä¸€ä¸ªåœ¨ç¨‹åºè¿è¡Œæ—¶ï¼ˆruntimeï¼‰è´Ÿè´£åŠ è½½å’Œé“¾æ¥å…±äº«åº“ï¼ˆshared librariesï¼‰çš„ç³»ç»Ÿè½¯ä»¶ç»„ä»¶ã€‚è¿™æ˜¯ç°ä»£æ“ä½œç³»ç»Ÿä¸­ä¸€ä¸ªå¤æ‚ä½†è‡³å…³é‡è¦çš„éƒ¨åˆ†ã€‚ä»¥ä¸‹æ˜¯åŠ¨æ€é“¾æ¥å™¨çš„å·¥ä½œåŸç†çš„ç®€è¦æ¦‚è¿°ï¼š

1. **åŠ è½½ç¨‹åºæ—¶çš„åŠ¨æ€é“¾æ¥**ï¼š
   - å½“ä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ï¼ˆæ¯”å¦‚ä¸€ä¸ªç¨‹åºæˆ–è€…åº”ç”¨ï¼‰å¯åŠ¨æ—¶ï¼Œæ“ä½œç³»ç»Ÿé¦–å…ˆå°†å…¶åŠ è½½åˆ°å†…å­˜ä¸­ã€‚
   - åŠ¨æ€é“¾æ¥å™¨æ£€æŸ¥å¯æ‰§è¡Œæ–‡ä»¶çš„å¤´éƒ¨ä¿¡æ¯ï¼Œç¡®å®šå®ƒä¾èµ–å“ªäº›å…±äº«åº“ã€‚
   - åŠ¨æ€é“¾æ¥å™¨ç„¶ååŠ è½½è¿™äº›å…±äº«åº“ï¼ˆå¦‚æœå®ƒä»¬è¿˜æ²¡æœ‰åœ¨å†…å­˜ä¸­çš„è¯ï¼‰ã€‚è¿™äº›å…±äº«åº“é€šå¸¸æ˜¯`.so`ï¼ˆLinuxï¼‰æˆ–`.dll`ï¼ˆWindowsï¼‰æ–‡ä»¶ã€‚
2. **è§£æç¬¦å·å’Œåœ°å€**ï¼š
   - æ¯ä¸ªå…±äº«åº“åŒ…å«ä¸€ç³»åˆ—çš„ç¬¦å·ï¼ˆsymbolsï¼‰ï¼Œæ¯”å¦‚å‡½æ•°å’Œå˜é‡çš„åç§°ã€‚
   - åŠ¨æ€é“¾æ¥å™¨è§£æè¿™äº›ç¬¦å·çš„åœ°å€ã€‚è¿™æ„å‘³ç€å®ƒç¡®å®šæ¯ä¸ªç¬¦å·åœ¨å†…å­˜ä¸­çš„å…·ä½“ä½ç½®ã€‚
   - å½“ç¨‹åºè°ƒç”¨ä¸€ä¸ªåœ¨å…±äº«åº“ä¸­çš„å‡½æ•°æ—¶ï¼ŒåŠ¨æ€é“¾æ¥å™¨ç¡®ä¿è¿™ä¸ªè°ƒç”¨è¢«é‡å®šå‘ï¼ˆredirectï¼‰åˆ°æ­£ç¡®çš„å†…å­˜åœ°å€ã€‚
3. **æ‡’æƒ°é“¾æ¥ï¼ˆLazy Linkingï¼‰**ï¼š
   - åœ¨æŸäº›ç³»ç»Ÿä¸­ï¼ŒåŠ¨æ€é“¾æ¥å™¨é‡‡ç”¨â€œæ‡’æƒ°é“¾æ¥â€ç­–ç•¥ã€‚è¿™æ„å‘³ç€å®ƒåªåœ¨ç¬¦å·ç¬¬ä¸€æ¬¡è¢«è®¿é—®æ—¶æ‰è§£æå…¶åœ°å€ã€‚
   - è¿™å¯ä»¥æé«˜ç¨‹åºå¯åŠ¨é€Ÿåº¦ï¼Œå› ä¸ºå¹¶ä¸æ˜¯æ‰€æœ‰çš„ç¬¦å·éƒ½éœ€è¦ç«‹å³è§£æã€‚
4. **ç¬¦å·é‡å®šä½ï¼ˆRelocationï¼‰**ï¼š
   - ç”±äºå…±äº«åº“å¯ä»¥è¢«åŠ è½½åˆ°å†…å­˜çš„ä»»æ„ä½ç½®ï¼ŒåŠ¨æ€é“¾æ¥å™¨éœ€è¦è°ƒæ•´ï¼ˆrelocateï¼‰åº“ä¸­ç¬¦å·çš„åœ°å€ï¼Œä½¿å…¶åæ˜ å®ƒä»¬åœ¨å†…å­˜ä¸­çš„å®é™…ä½ç½®ã€‚
5. **å…¨å±€åç§»è¡¨ï¼ˆGOTï¼‰å’Œç¨‹åºé“¾æ¥è¡¨ï¼ˆPLTï¼‰**ï¼š
   - åœ¨ä¸€äº›å®ç°ä¸­ï¼ŒåŠ¨æ€é“¾æ¥å™¨ä½¿ç”¨å…¨å±€åç§»è¡¨ï¼ˆGOTï¼‰å’Œç¨‹åºé“¾æ¥è¡¨ï¼ˆPLTï¼‰æ¥ç®¡ç†å¤–éƒ¨å‡½æ•°è°ƒç”¨ã€‚
   - GOTç”¨äºå­˜å‚¨ç¬¦å·çš„å®é™…åœ°å€ï¼Œè€ŒPLTç”¨äºå¤„ç†å‡½æ•°è°ƒç”¨çš„åˆå§‹é˜¶æ®µã€‚
6. **å¤„ç†ç‰ˆæœ¬æ§åˆ¶å’Œå…¼å®¹æ€§**ï¼š
   - åŠ¨æ€é“¾æ¥å™¨è¿˜è´Ÿè´£å¤„ç†åº“ç‰ˆæœ¬æ§åˆ¶ï¼Œç¡®ä¿ç¨‹åºä½¿ç”¨çš„æ˜¯æ­£ç¡®ç‰ˆæœ¬çš„å…±äº«åº“ã€‚
   - å®ƒè¿˜å¯èƒ½æ‰§è¡Œä¸€äº›å…¼å®¹æ€§æ£€æŸ¥ï¼Œä»¥ç¡®ä¿åº“ä¸ç¨‹åºå…¼å®¹ã€‚

# visual stdio debug

we can use debug window in visual stdio, and see what is in memory.

![Untitled](./c++/Untitled%201.png)

![Untitled](./c++/Untitled%202.png)

We also can use â€œdisassemblyâ€ to check æ±‡ç¼–ä»£ç 

![Untitled](./c++/Untitled%203.png)

## Visual Stdio æ–‡ä»¶ç›®å½•è®¾ç½®

æŠŠsolutionæ”¾åœ¨ä¸€ä¸ªå•ç‹¬çš„æ–‡ä»¶å¤¹ä¸­ï¼Œ å°†è¾“å‡ºä¸­é—´æ–‡ä»¶ å’Œè¾“å‡ºæ–‡ä»¶æ”¾åœ¨binä¸­ï¼Œå¹¶åˆ†æˆä¸¤ä¸ªæ–‡ä»¶å¤¹

![Untitled](./c++/Untitled%204.png)

![Untitled](./c++/Untitled%205.png)

![Untitled](./c++/Untitled%206.png)

![Untitled](./c++/Untitled%207.png)

# pointer and &

â€œ&â€ can help you to get address of variable;

```cpp
//pointer
	int y = 100;
	int *x;
	x=&y; // get address
	cout << x << endl;

	y=500;
	cout << x <<endl;

//out
0x84ff9ff794
0x84ff9ff794
```

***x = &y â‡’ x is the address of y, while *x is the value of y**

```cpp
int x[5] = {1,2,3,4,5};
int *q,*p = &x[0];

q=p;
for(int i = 0; i<5; i++){
	int a = (*q++)++;
	cout << *q << endl;
	cout << q << endl;
}
```

ä»¥ä¸Šä»£ç çš„è§£é‡Šï¼š

> åœ¨C++ä¸­ï¼Œ**`(*p++)++`** æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæ¶‰åŠæŒ‡é’ˆå’Œé€’å¢è¿ç®—ç¬¦ã€‚è®©æˆ‘ä»¬é€æ­¥è§£é‡Šè¿™ä¸ªè¡¨è¾¾å¼çš„å«ä¹‰ï¼š
> 
> 1. **`p`** æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œå®ƒæŒ‡å‘æŸä¸ªæ•°æ®ç±»å‹çš„å¯¹è±¡ã€‚
> 2. **`p`** è¡¨ç¤ºå¯¹æŒ‡é’ˆ **`p`** æŒ‡å‘çš„å¯¹è±¡è¿›è¡Œè§£å¼•ç”¨ï¼Œå³è·å–æŒ‡é’ˆæ‰€æŒ‡å‘ä½ç½®çš„å€¼ã€‚
> 
> ç°åœ¨ï¼Œè®©æˆ‘ä»¬åˆ†ææ•´ä¸ªè¡¨è¾¾å¼ **`(*p++)++`** çš„æ‰§è¡Œè¿‡ç¨‹ï¼š
> 
> 1. **`(*p++)`**ï¼š
>     - **`p++`** æ˜¯åç¼€é€’å¢è¿ç®—ç¬¦ï¼Œå®ƒä¼šå…ˆä½¿ç”¨ **`p`** çš„å€¼ï¼Œç„¶åå†å°† **`p`** çš„å€¼å¢åŠ  1ï¼Œå³æŒ‡å‘ä¸‹ä¸€ä¸ªä½ç½®ã€‚
>     - **`p`** è¡¨ç¤ºå¯¹å½“å‰ **`p`** æŒ‡å‘çš„ä½ç½®è¿›è¡Œè§£å¼•ç”¨ï¼Œè·å–è¯¥ä½ç½®çš„å€¼ã€‚
>     
>     å› æ­¤ï¼Œ**`(*p++)`** å°†é¦–å…ˆè§£å¼•ç”¨ **`p`** æŒ‡å‘çš„ä½ç½®çš„å€¼ï¼Œç„¶åå°† **`p`** æŒ‡å‘ä¸‹ä¸€ä¸ªä½ç½®ã€‚
>     
> 2. **`++`**ï¼š
>     - è¿™æ˜¯å‰ç¼€é€’å¢è¿ç®—ç¬¦ï¼Œå®ƒä¼šå°†å‰é¢ **`(*p++)`** çš„ç»“æœå†åŠ  1ã€‚
> 
> ç»¼åˆèµ·æ¥ï¼Œ**`(*p++)++`** çš„æ‰§è¡Œè¿‡ç¨‹æ˜¯ï¼š
> 
> - é¦–å…ˆï¼Œè§£å¼•ç”¨ **`p`** æŒ‡å‘çš„ä½ç½®ï¼Œè·å–è¯¥ä½ç½®çš„å€¼ã€‚
> - ç„¶åï¼Œå°† **`p`** æŒ‡å‘ä¸‹ä¸€ä¸ªä½ç½®ã€‚
> - æœ€åï¼Œå°†å‰é¢è·å–çš„å€¼åŠ  1ã€‚
> 
> è¯·æ³¨æ„ï¼Œè¿™ç§ä»£ç å¯èƒ½ä¼šå¯¼è‡´ä»£ç å¯è¯»æ€§å˜å·®ï¼Œå»ºè®®å°½é‡é¿å…ç¼–å†™å¤æ‚çš„è¡¨è¾¾å¼ï¼Œä»¥ç¡®ä¿ä»£ç çš„æ¸…æ™°å’Œæ˜“è¯»æ€§ã€‚
> 
> ä¸‹é¢å†ç»™å‡ºå…³äº(*p++)++çš„æ±‡ç¼–ä»£ç 
> 
> ```csharp
> mov	eax, DWORD PTR _p$[ebp]
> mov	ecx, DWORD PTR [eax]
> add	ecx, 1 //å…ˆå¢åŠ å€¼
> mov	edx, DWORD PTR _p$[ebp]
> mov	DWORD PTR [edx], ecx
> mov	eax, DWORD PTR _p$[ebp]
> add	eax, 4 //å†ç§»åŠ¨ä½ç½®
> mov	DWORD PTR _p$[ebp], eax
> ```
> 

## void*

void pointer type can point to the address of any types of variable. But void pointer cannot be dereferenced, (int *)p == p;  *(int *)p = *p;  **When you define a void* , you must translate it to specific type when you use it.**

```cpp
int a =5;
void *p = &a;

cout << *(int*)p << endl;
```

## void**

pointer store the address of variable, so the pointer to pointer store the address of pointer.

---

<aside>
ğŸ’¡ å…³äºSingleton& singletonInstance = Singleton::getInstance(); å‰é¢çš„ç±»å‹åé¢ä¸ºä»€ä¹ˆè¦åŠ &ï¼š

**åœ¨è¿™æ®µä»£ç ä¸­ï¼Œ`Singleton& singletonInstance` å®šä¹‰äº†ä¸€ä¸ªå¼•ç”¨å˜é‡ `singletonInstance`ï¼Œå®ƒå¼•ç”¨äº†ä¸€ä¸ªåä¸º `Singleton` çš„ç±»çš„å®ä¾‹ã€‚**

**åœ¨ C++ ä¸­ï¼Œå¼•ç”¨ï¼ˆ`&`ï¼‰ç”¨äºåˆ›å»ºä¸€ä¸ªåˆ«åï¼Œå®ƒå…è®¸ä½ åœ¨ä»£ç ä¸­ä½¿ç”¨ä¸€ä¸ªå˜é‡åæ¥è®¿é—®å¦ä¸€ä¸ªå·²ç»å­˜åœ¨çš„å¯¹è±¡ï¼Œè€Œä¸æ˜¯åˆ›å»ºä¸€ä¸ªæ–°çš„å‰¯æœ¬ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ`Singleton& singletonInstance` å£°æ˜äº†ä¸€ä¸ªå¼•ç”¨ï¼Œè¯¥å¼•ç”¨å¯ä»¥å¼•ç”¨ `Singleton` ç±»çš„å®ä¾‹ã€‚**

**é€šè¿‡ `Singleton::getInstance()` å‡½æ•°è·å– `Singleton` ç±»çš„å®ä¾‹ï¼Œå¹¶å°†å…¶èµ‹ç»™ `singletonInstance` å¼•ç”¨ã€‚è¿™æ ·ï¼Œä½ å°±å¯ä»¥é€šè¿‡ `singletonInstance` å¼•ç”¨æ¥è®¿é—® `Singleton` ç±»çš„å®ä¾‹ï¼Œè€Œä¸éœ€è¦å¤åˆ¶è¯¥å®ä¾‹çš„å†…å®¹ã€‚**

**ä½¿ç”¨å¼•ç”¨çš„å¥½å¤„æ˜¯é¿å…äº†å¯¹è±¡çš„å¤åˆ¶ï¼Œæé«˜äº†ç¨‹åºçš„æ•ˆç‡ï¼ŒåŒæ—¶ç¡®ä¿æ“ä½œçš„æ˜¯åŒä¸€ä¸ªå¯¹è±¡å®ä¾‹ã€‚**

**å¦‚æœä¸åŠ  `&`ï¼Œåˆ™ `Singleton& singletonInstance` å°†è¢«è§£é‡Šä¸ºå£°æ˜ä¸€ä¸ªå¯¹è±¡è€Œä¸æ˜¯å¼•ç”¨ã€‚è¿™æ„å‘³ç€åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ å°†åˆ›å»ºä¸€ä¸ªæ–°çš„ `Singleton` ç±»çš„å®ä¾‹ï¼Œå¹¶å°†å…¶å¤åˆ¶ç»™ `singletonInstance`ï¼Œè€Œä¸æ˜¯å¼•ç”¨ç°æœ‰çš„å®ä¾‹ã€‚**

**ç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼š**

```cpp
Singleton singletonInstance = Singleton::getInstance();  // åˆ›å»ºå¹¶å¤åˆ¶ Singleton å®ä¾‹

```

**è¿™æ ·ï¼Œ`singletonInstance` å°†æˆä¸ºä¸€ä¸ªæ–°çš„ `Singleton` ç±»çš„å®ä¾‹çš„å‰¯æœ¬ï¼Œè€Œä¸æ˜¯å¼•ç”¨åŸæœ‰çš„å®ä¾‹ã€‚å¦‚æœä½ åœ¨ä»£ç ä¸­å¯¹ `singletonInstance` è¿›è¡Œæ“ä½œï¼Œä¼šæ“ä½œè¿™ä¸ªæ–°åˆ›å»ºçš„å®ä¾‹ï¼Œä¸ä¼šå½±å“åŸæœ‰çš„ `Singleton` å®ä¾‹ã€‚**

**é€šå¸¸æƒ…å†µä¸‹ï¼Œåœ¨å•ä¾‹æ¨¡å¼ä¸­ï¼Œæˆ‘ä»¬å¸Œæœ›é€šè¿‡å¼•ç”¨æ¥æ“ä½œå•ä¾‹å¯¹è±¡ï¼Œä»¥ç¡®ä¿æˆ‘ä»¬å§‹ç»ˆåœ¨æ“ä½œåŒä¸€ä¸ªå®ä¾‹ï¼Œè€Œä¸æ˜¯åˆ›å»ºæ–°çš„å®ä¾‹ã€‚å› æ­¤ï¼Œåœ¨å•ä¾‹æ¨¡å¼ä¸­ï¼Œé€šå¸¸ä¼šä½¿ç”¨å¼•ç”¨æˆ–æŒ‡é’ˆæ¥è·å–å•ä¾‹å®ä¾‹ã€‚**

</aside>

# Reference

å’ŒæŒ‡é’ˆé…åˆä½¿ç”¨

```csharp
void Add(int* p)
{
	(*p)++;
}
int main() {
	int a = 10;
	Add(&a);
	Log(a);
}
```

```csharp
void Add(int& p)
{
	p++;
}

int a = 10;
	Add(a);
```

ä»¥ä¸Šä¸¤ä¸ªä»£ç æ˜¯ä¸€æ¨¡ä¸€æ ·çš„

# Class

## whatâ€™s the different in class and struct

in struct everything is public, but in class we can define â€œprivateâ€ and â€œpublicâ€ to variable or method.

if we just want to store simple data, we can use struct, like **Vector**

# Static in C++ & C#

åœ¨C++å’ŒC#ä¸­ï¼Œ`static` å…³é”®å­—å…·æœ‰ä¸åŒçš„å«ä¹‰å’Œç”¨æ³•ã€‚

## C++

åœ¨C++ä¸­ï¼Œ`static` å…³é”®å­—ç”¨äºè¡¨ç¤ºä»¥ä¸‹å‡ ç§æƒ…å†µï¼š

1. **é™æ€å˜é‡ (static variables)**:
   åœ¨å‡½æ•°å†…éƒ¨å£°æ˜çš„å˜é‡ï¼Œå…¶ç”Ÿå‘½å‘¨æœŸä¸ç¨‹åºçš„è¿è¡Œå‘¨æœŸç›¸åŒã€‚é™æ€å˜é‡åœ¨é¦–æ¬¡å£°æ˜æ—¶è¢«åˆå§‹åŒ–ï¼Œä¹‹åçš„å‡½æ•°è°ƒç”¨ä¼šä¿æŒè¯¥å˜é‡çš„å€¼ã€‚
   
    ```cpp
    void foo() {
        static int count = 0;
        count++;
        std::cout << "Count: " << count << std::endl;
    }
    
    ```
   
2. **é™æ€å‡½æ•° (static functions)**:
   å‡½æ•°å‰åŠ  `static` å…³é”®å­—ï¼Œä½¿å…¶å…·æœ‰å†…éƒ¨é“¾æ¥ï¼Œåªèƒ½åœ¨å½“å‰æ–‡ä»¶ä¸­è®¿é—®ã€‚
   
    ```cpp
    static void staticFunction() {
        // Function code
    }
    
    ```
   
3. **é™æ€æ•°æ®æˆå‘˜ (static data members)**:
   ç±»çš„æ‰€æœ‰å¯¹è±¡å…±äº«åŒä¸€ä¸ªé™æ€æ•°æ®æˆå‘˜ã€‚è¿™ä¸ªé™æ€æ•°æ®æˆå‘˜å±äºç±»ï¼Œè€Œä¸æ˜¯å±äºç±»çš„å¯¹è±¡ã€‚
   
    ```cpp
    class MyClass {
    public:
        static int staticDataMember;
    };
    
    int MyClass::staticDataMember = 10;  // Initialization of static data member
    
    int main() {
        std::cout << MyClass::staticDataMember << std::endl;  // Accessing static data member
        return 0;
    }
    
    ```
   

## C#

åœ¨C#ä¸­ï¼Œ`static` å…³é”®å­—ç”¨äºè¡¨ç¤ºä»¥ä¸‹å‡ ç§æƒ…å†µï¼š

1. **é™æ€ç±» (static class)**:
   ä½¿ç”¨ `static` ä¿®é¥°çš„ç±»æ˜¯é™æ€ç±»ï¼Œå…¶ä¸­çš„æˆå‘˜ä¹Ÿå¿…é¡»æ˜¯é™æ€çš„ã€‚é™æ€ç±»ä¸èƒ½è¢«å®ä¾‹åŒ–ï¼Œä¸”æ‰€æœ‰æˆå‘˜å¯ä»¥ç›´æ¥é€šè¿‡ç±»åè®¿é—®ã€‚
   
    ```csharp
    public static class StaticClass {
        public static int StaticMember { get; set; }
        public static void StaticMethod() {
            // Method code
        }
    }
    
    ```
   
2. **é™æ€æ–¹æ³• (static methods)**:
   ä½¿ç”¨ `static` ä¿®é¥°çš„æ–¹æ³•æ˜¯é™æ€æ–¹æ³•ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡ç±»åè°ƒç”¨ï¼Œè€Œä¸éœ€è¦å®ä¾‹åŒ–å¯¹è±¡ã€‚
   
    ```csharp
    public class MyClass {
        public static void StaticMethod() {
            // Method code
        }
    }
    
    ```
   
3. **é™æ€å­—æ®µ (static fields)**:
   ä½¿ç”¨ `static` ä¿®é¥°çš„å­—æ®µæ˜¯é™æ€å­—æ®µï¼Œå®ƒä»¬å±äºç±»è€Œä¸æ˜¯ç±»çš„å®ä¾‹ã€‚æ‰€æœ‰ç±»çš„å®ä¾‹å…±äº«ç›¸åŒçš„é™æ€å­—æ®µã€‚
   
    ```csharp
    public class MyClass {
        public static int StaticField;
    }
    
    ```
   

æ€»ç»“æ¥è¯´ï¼Œåœ¨C++ä¸­ï¼Œ`static` ä¸»è¦ç”¨äºé™æ€å˜é‡ã€é™æ€å‡½æ•°å’Œé™æ€æ•°æ®æˆå‘˜ï¼Œè€Œåœ¨C#ä¸­ï¼Œ`static` ç”¨äºé™æ€ç±»ã€é™æ€æ–¹æ³•å’Œé™æ€å­—æ®µã€‚

# C++ ç±»å‹è½¬æ¢

C++ä¸­æœ‰å¤šç§ç±»å‹è½¬æ¢æ–¹æ³•ï¼Œå¯ä»¥æ ¹æ®ä¸åŒçš„éœ€æ±‚é€‰æ‹©é€‚å½“çš„è½¬æ¢æ–¹å¼ã€‚ä»¥ä¸‹æ˜¯å¸¸ç”¨çš„ç±»å‹è½¬æ¢æ–¹æ³•ï¼š

1. **é™æ€è½¬æ¢ï¼ˆstatic_castï¼‰**ï¼š
   `static_cast` ç”¨äºæ‰§è¡Œéå¤šæ€ç±»å‹çš„è½¬æ¢ï¼Œä¾‹å¦‚æ•°å€¼ç±»å‹ä¹‹é—´çš„è½¬æ¢ã€æŒ‡é’ˆç±»å‹çš„è½¬æ¢ç­‰ã€‚å®ƒåœ¨ç¼–è¯‘æ—¶è¿›è¡Œç±»å‹æ£€æŸ¥ï¼Œä¸è¿›è¡Œè¿è¡Œæ—¶æ£€æŸ¥ã€‚
   
    ```cpp
    double d = 3.14;
    int i = static_cast<int>(d);  // å°† double è½¬æ¢ä¸º int
    
    ```
   
2. **åŠ¨æ€è½¬æ¢ï¼ˆdynamic_castï¼‰**ï¼š
   `dynamic_cast` ç”¨äºæ‰§è¡Œå«æœ‰è™šå‡½æ•°çš„ç±»å±‚æ¬¡ç»“æ„ä¸­çš„å®‰å…¨å‘ä¸‹è½¬å‹ã€‚å®ƒåœ¨è¿è¡Œæ—¶è¿›è¡Œç±»å‹æ£€æŸ¥ï¼Œåªèƒ½ç”¨äºå¤šæ€ç±»å‹ä¹‹é—´çš„è½¬æ¢ã€‚
   
    ```cpp
    class Base {
        virtual void foo() {}
    };
    
    class Derived : public Base {};
    
    Base* basePtr = new Derived();
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);  // å®‰å…¨å‘ä¸‹è½¬å‹
    
    ```
   
3. **å¸¸é‡è½¬æ¢ï¼ˆconst_castï¼‰**ï¼š
   `const_cast` ç”¨äºæ·»åŠ æˆ–ç§»é™¤å˜é‡çš„ const é™å®šç¬¦ã€‚å®ƒå¯ä»¥å°†å¸¸é‡è½¬æ¢ä¸ºéå¸¸é‡ï¼Œåä¹‹äº¦ç„¶ã€‚
   
    ```cpp
    const int num = 10;
    int* nonConstPtr = const_cast<int*>(&num);  // å°†å¸¸é‡æŒ‡é’ˆè½¬æ¢ä¸ºéå¸¸é‡æŒ‡é’ˆ
    
    ```
   
4. **é‡æ–°è§£é‡Šè½¬æ¢ï¼ˆreinterpret_castï¼‰**ï¼š
   `reinterpret_cast` ç”¨äºä½çº§åˆ«çš„è½¬æ¢ï¼Œå®ƒå¯ä»¥å°†ä»»ä½•æŒ‡é’ˆç±»å‹è½¬æ¢ä¸ºä»»ä½•å…¶ä»–æŒ‡é’ˆç±»å‹ã€‚é€šå¸¸ç”¨äºå¤„ç†åº•å±‚çš„è½¬æ¢ï¼Œé£é™©è¾ƒé«˜ï¼Œéœ€è°¨æ…ä½¿ç”¨ã€‚
   
    ```cpp
    int i = 10;
    double* ptr = reinterpret_cast<double*>(&i);  // å°† int æŒ‡é’ˆè½¬æ¢ä¸º double æŒ‡é’ˆ
    
    ```
   

è¿™äº›ç±»å‹è½¬æ¢æ“ä½œè¦æ…ç”¨ï¼Œå°¤å…¶æ˜¯ `reinterpret_cast` å’Œ `const_cast`ï¼Œå› ä¸ºå®ƒä»¬å¯èƒ½ä¼šå¼•å…¥ç¨‹åºé”™è¯¯æˆ–ä¸å¯é¢„çŸ¥çš„è¡Œä¸ºã€‚åœ¨ä½¿ç”¨ç±»å‹è½¬æ¢æ—¶ï¼Œåº”è°¨æ…è€ƒè™‘ç¨‹åºçš„è®¾è®¡å’Œå®‰å…¨æ€§ã€‚

# Array

- ğŸ“ åŠ¨æ€åˆ†é…æ•°ç»„
ä»‹ç»äº†ä½¿ç”¨ `new` å…³é”®å­—åŠ¨æ€åˆ†é…æ•°ç»„å†…å­˜ï¼Œå¹¶å¯¹æ¯”äº†åŠ¨æ€åˆ†é…å’Œé™æ€åˆ†é…çš„åŒºåˆ«ä»¥åŠéœ€è¦æ³¨æ„çš„å†…å­˜é‡Šæ”¾é—®é¢˜ã€‚
- ğŸ“ æŒ‡é’ˆä¸æ•°ç»„
  è®¨è®ºäº†æ•°ç»„ä¸æŒ‡é’ˆçš„å…³ç³»ï¼Œä»¥åŠå¦‚ä½•é€šè¿‡æŒ‡é’ˆæ“ä½œæ•°ç»„å…ƒç´ ï¼ŒåŒ…æ‹¬ä½¿ç”¨æŒ‡é’ˆç®—æœ¯è¿›è¡Œæ•°ç»„å…ƒç´ çš„è®¿é—®ã€‚
  
    ```cpp
    int example[5];
    	example[0] = 5;
    	int* ptr = example;
    
    	//*(ptr + 2) = 6;
    	*(int*)((char*)ptr + 8) = 6;
    ```
  
- ä½¿ç”¨æ ‡å‡†æ•°ç»„
  æåŠäº† C++11 ä¸­å¼•å…¥çš„ `std::array` æ•°æ®ç»“æ„ï¼Œä¸ä¼ ç»Ÿæ•°ç»„ç›¸æ¯”å…·æœ‰æ›´å¤šä¼˜åŠ¿ã€‚
  
    ```cpp
    #include<array>
    
    array<int,5> arr = {0,1,2,3,4};
    int len = arr.size();
    ```
  
- ğŸ§¾ åœ¨å †ä¸Šåˆ†é…æ•°ç»„ï¼Œæ— æ³•ç›´æ¥è·å–å¤§å°,åœ¨å †ä¸Šåˆ†é…æ•°ç»„åï¼Œæ— æ³•é€šè¿‡ç±»ä¼¼ "example.size" çš„æ–¹å¼è·å–å¤§å°.åœ¨å †ä¸Šåˆ†é…æ•°ç»„åï¼Œåˆ é™¤æ•°ç»„æ—¶éœ€è¦çŸ¥é“åˆ†é…çš„å†…å­˜å¤§å°,å †ä¸Šæ•°ç»„çš„å¤§å°å¯èƒ½å­˜å‚¨åœ¨è´Ÿç´¢å¼•ä½ç½®
- ğŸ§¾ åˆ†é…æ•°ç»„åœ¨æ ˆä¸Šæ—¶ï¼Œå¯ä»¥é€šè¿‡è·å–æ•°æ®ç±»å‹å¤§å°å’Œå…ƒç´ æ•°é‡è®¡ç®—å¤§å°, æ ˆä¸Šæ•°ç»„çš„å¤§å°æ˜¯å…ƒç´ æ•°é‡è€Œéå­—èŠ‚æ•°
- ğŸ§¾ é™æ€æ•°ç»„å¤§å°éœ€åœ¨ç¼–è¯‘æ—¶å·²çŸ¥
- ğŸ§¾ æ¨èä½¿ç”¨å¸¸é‡æ¥ç®¡ç†æ•°ç»„å¤§å°
- ğŸ§¾ æ ‡å‡†æ•°ç»„ï¼ˆstd::arrayï¼‰æ˜¯æ›´å®‰å…¨çš„é€‰æ‹©ï¼Œä½†å¯èƒ½æœ‰é¢å¤–å¼€é”€
- ğŸ§¾ åŸå§‹æ•°ç»„ï¼ˆraw arraysï¼‰å¯èƒ½æ›´å¿«ï¼Œä½†ä¸å¦‚æ ‡å‡†æ•°ç»„å®‰å…¨

# å­—ç¬¦ä¸²

## å­—ç¬¦ä¸²æ˜¯å¦‚ä½•å·¥ä½œçš„

```cpp
static const char* name = "Russell";
cout << name[2] << endl;
//ç­‰åŒäºä»¥ä¸‹ä»£ç 
char name2[9] = { 'R','u','s','s','e','l','l',0 };
```

å­—ç¬¦ä¸²å®é™…ä¸Šæ˜¯ä¸€ä¸ªå­—ç¬¦æ•°ç»„ï¼Œä»¥\0ç»“æŸ

std::stringå°±æ˜¯åœ¨è¿™åŸºç¡€ä¸Šåšäº†ä¸€å±‚å°è£…ï¼Œå®é™…ä¸Šæ˜¯ä¸€ä¸ªä¸œè¥¿

# Const

1. ç¬¬ä¸€ç§ç”¨æ³•ï¼šè§„å®šæŸä¸€ä¸ªå˜é‡ä¸å¯ä¿®æ”¹
   
    ```cpp
    const int a = "xxx";
    ```
    
2. ç¬¬äºŒç§ç”¨æ³•ï¼Œè®¾å®šæŒ‡é’ˆä¸å¯ä¿®æ”¹çš„éƒ¨åˆ†
   
    ```cpp
    //1.è¿™ç§å†™æ³•aæŒ‡é’ˆæ˜¯å®Œå…¨ä¸èƒ½ä¿®æ”¹çš„
    const int* a = new int; // = int const* a = new int;
    //2.è¿™ç§å†™æ³•aæŒ‡é’ˆå¯ä»¥ä¿®æ”¹å€¼ä½†ä¸èƒ½ä¿®æ”¹æŒ‡å‘çš„ä½ç½®
    int* const b = new int;
    *b = 3; // å¯ä»¥ä¿®æ”¹å€¼
    //*b = &9; //ä½†ä¸èƒ½ä¿®æ”¹æŒ‡é’ˆæ‰€æŒ‡å‘çš„ä½ç½®
    ```
    
3. ç»™å‡½æ•°æ·»åŠ é™å®šï¼Œä½¿ä½œç”¨åŸŸå†…çš„å˜é‡ä¸èƒ½è¢«ä¿®æ”¹ï¼Œå…¶å®ä»»ä½•ä¸€ä¸ªä¸éœ€è¦ä¿®æ”¹å€¼çš„å‡½æ•°éƒ½åº”è¯¥å¢åŠ const, ä½†æ˜¯å¯ä»¥é€šè¿‡ç»™å˜é‡å¢åŠ mutableé™å®šç¬¦ï¼Œä½¿å˜é‡åœ¨constä½œç”¨åŸŸä¸­å¯ä»¥è¢«ä¿®æ”¹
   
    ```cpp
    string& MyClass::MyFunc() const
    {
    	return name;
    }
    ```
    
    # Mutable
    
    1. ä¸Šè¿°ç”¨æ³•
    2. åœ¨lambdaè¡¨è¾¾å¼ä¸­ä½¿ç”¨
       
        ```cpp
        int x = 0;
        	auto f = [=]() mutable //ä¼ å€¼è¿›å»
        	{
        		x++;
        		cout << x << endl;
        	};
        ```
        
    
    # æ„é€ å‡½æ•°åˆ—è¡¨
    
    ```cpp
    class MyClass
    {
    public:
    	Example example;
    	int a;
    	int b;
    public:
    	//è¿™å°±æ˜¯æ„é€ å‡½æ•°åˆ—è¡¨
    	MyClass(Example ex, int a, int b):example(ex),a(a),b(b)
    	{
    		
    	}
    	string MyFunc() const;
    private:
    	string name;
    };
    ```
    
    ```cpp
    class MyClass
    {
    public:
    	Example example;
    public:
    	MyClass()
    	{
    		//ä¸è¦è¿™ä¹ˆå†™
    		example = Example(8);
    	}
    	string MyFunc() const;
    private:
    	string name;
    };
    ```
    
    ä¸Šè¿°ä¸¤ä¸ªä»£ç å—å…¶å®æ˜¯ä¸¤ç§åŠŸèƒ½ï¼Œç¬¬äºŒä¸ªä»£ç å—ä¼šæ‰§è¡Œä¸¤æ¬¡Exampleæ„é€ å‡½æ•°ï¼Œä¸€ä¸ªæ˜¯é»˜è®¤çš„ï¼Œä¸€ä¸ªæ˜¯å¸¦å‚æ•°çš„
    
    # C++ ä¸¤ç§åˆ›å»ºå¯¹è±¡çš„æ–¹å¼
    
    1. ç¬¬ä¸€ç§æ–¹å¼ï¼šè¿™ç§æ–¹å¼ä¼šåœ¨å †æ ˆä¸­åˆ›å»ºå¯¹è±¡ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸éœ€è¦å»ç®¡å†…å­˜çš„é‡Šæ”¾ï¼Œè¿™ç§æ–¹å¼æ˜¯æ¯”è¾ƒå®‰å…¨çš„ï¼Œä¹Ÿæ˜¯æ•ˆç‡æ¯”è¾ƒé«˜çš„ï¼Œæ‰€ä»¥**éå¸¸æ¨èç”¨è¿™ç§æ–¹å¼åˆ›å»ºå¯¹è±¡ï¼ï¼ï¼**
    
    ```cpp
    A a("XX")
    ```
    
    1. ç¬¬äºŒç§æ–¹å¼å®åœ¨å †ä¸­ï¼Œåœ¨å †ä¸­çš„å¯¹è±¡éœ€è¦è‡ªå·±æ‰‹åŠ¨é‡Šæ”¾ï¼Œå †æ¯”è¾ƒå¤§ï¼Œé€‚ç”¨äºåˆ›å»ºå¤§é‡çš„å¯¹è±¡çš„æƒ…å†µï¼Œä½†æ˜¯è¿™ç§æ–¹å¼ä¸å®‰å…¨ï¼Œå¯èƒ½é€ æˆå†…å­˜æ³„æ¼ã€‚å¯ä»¥è€ƒè™‘ç”¨æ™ºèƒ½æŒ‡é’ˆæ›¿æ¢
       
        ```cpp
        A* a = new A("XX);
        ```
        
    
    # éšå¼è½¬æ¢
    
    ```cpp
    class MyTest
    {
    private:
    	int name; // Explicit int name è¿™ç§æ–¹å¼å°±å¿…é¡»æ˜¾ç¤ºè°ƒç”¨constructor
    	string age;
    public:
    	MyTest(int n) :name(n) {}
    	MyTest(const string& a) :age(a) {}
    };
    
    void PrintAge(const MyTest& test)
    {
    	cout << "asdasdasd" << endl;
    }
    
    int main() {
    	//éšå¼è½¬æ¢
    	MyTest test = 22;
    
    	//è¿™ç§å†™æ³•å…¶å®ä¼šéœ€è¦ä¸¤ç§è½¬æ¢"afasd"æœ¬è´¨æ˜¯ä¸€ä¸ªå­—ç¬¦æ•°ç»„ï¼Œå®ƒéœ€è¦å…ˆè½¬æ¢æˆstringï¼Œ
    	// ç„¶ååœ¨éšå¼è½¬æ¢è°ƒç”¨æ„é€ å‡½æ•°ï¼Œè€Œéšå¼è½¬æ¢åªå…è®¸å‘ç”Ÿä¸€æ¬¡
    	//PrintAge("afasd"); 
    
    	//è¿™ç§æ˜¯å¯ä»¥çš„
    	PrintAge(MyTest("asdasd"));
    }
    ```
    
    ä½†æ˜¯å¦‚æœä½¿ç”¨äº†Explicitå…³é”®è¯ï¼Œéšå¼å°±ä¸èµ·ä½œç”¨äº†
    
    # thisæŒ‡é’ˆ
    
    - ğŸ“š ç†è§£C++ä¸­çš„thiså…³é”®å­—
        - åœ¨C++ä¸­ä»‹ç»äº†thiså…³é”®å­—ï¼Œå®ƒæ˜¯ä¸€ä¸ªæŒ‡å‘å½“å‰å¯¹è±¡å®ä¾‹çš„æŒ‡é’ˆï¼Œåªèƒ½é€šè¿‡æˆå‘˜å‡½æ•°è®¿é—®ã€‚
        - è§£é‡Šäº†thiså…³é”®å­—çš„ä½œç”¨ï¼Œä»¥åŠå¦‚ä½•åœ¨æ–¹æ³•ä¸­ä½¿ç”¨thisæ¥è®¿é—®ç±»çš„æˆå‘˜å˜é‡ã€‚
    - ğŸ“š ä½¿ç”¨thisæŒ‡é’ˆè¿›è¡Œæˆå‘˜å˜é‡èµ‹å€¼
        - æ¢è®¨äº†å¦‚ä½•é€šè¿‡thisæŒ‡é’ˆæ¥è§£å†³æˆå‘˜å˜é‡ä¸å‚æ•°åŒåçš„é—®é¢˜ï¼Œå®ç°æˆå‘˜å˜é‡èµ‹å€¼ã€‚
        - æ¼”ç¤ºäº†ä½¿ç”¨thisæŒ‡é’ˆè®¿é—®ç±»çš„æˆå‘˜å˜é‡å¹¶è¿›è¡Œèµ‹å€¼çš„ç¤ºä¾‹ã€‚
    - ğŸ“š ç†è§£constå‡½æ•°å’ŒthisæŒ‡é’ˆ
        - ä»‹ç»äº†åœ¨constå‡½æ•°ä¸­ä½¿ç”¨thisæŒ‡é’ˆï¼Œä»¥åŠthisæŒ‡é’ˆçš„ç±»å‹åœ¨constå’Œéconstå‡½æ•°ä¸­çš„åŒºåˆ«ã€‚
        - è§£é‡Šäº†åœ¨constæˆå‘˜å‡½æ•°ä¸­ï¼ŒthisæŒ‡é’ˆçš„ç±»å‹ä¸ºå¸¸é‡æŒ‡é’ˆï¼Œè€Œéconstæˆå‘˜å‡½æ•°ä¸­ä¸ºæ™®é€šæŒ‡é’ˆã€‚
        
        ```cpp
        class MyClass {
        public:
            int getValue() const {
                // åœ¨constæˆå‘˜å‡½æ•°ä¸­ï¼ŒthisæŒ‡é’ˆçš„ç±»å‹ä¸ºconst MyClass*
                // ä¸èƒ½é€šè¿‡thisæŒ‡é’ˆä¿®æ”¹å¯¹è±¡çš„æˆå‘˜å˜é‡
                // this->value = 10; // Error: Cannot modify a const object
                return value;
            }
        
        private:
            int value;
        };
        
        ---------------------------------------------------------------
        
        class MyClass {
        public:
            void setValue(int newValue) {
                // åœ¨éconstæˆå‘˜å‡½æ•°ä¸­ï¼ŒthisæŒ‡é’ˆçš„ç±»å‹ä¸ºMyClass*
                // å¯ä»¥é€šè¿‡thisæŒ‡é’ˆä¿®æ”¹å¯¹è±¡çš„æˆå‘˜å˜é‡
                this->value = newValue;
            }
        
        private:
            int value;
        };
        ```
        
    - ğŸ“š hisæŒ‡é’ˆç”¨äºè°ƒç”¨ç±»å¤–å‡½æ•°
        - è®²è§£äº†å¦‚ä½•ä½¿ç”¨thisæŒ‡é’ˆåœ¨ç±»å†…éƒ¨è°ƒç”¨ç±»å¤–éƒ¨çš„å‡½æ•°ï¼Œä¼ é€’å½“å‰ç±»çš„å®ä¾‹ä½œä¸ºå‚æ•°ã€‚
        - æ¼”ç¤ºäº†é€šè¿‡thisæŒ‡é’ˆè°ƒç”¨ç±»å¤–éƒ¨å‡½æ•°çš„æ–¹æ³•ï¼Œå¹¶è®¨è®ºäº†ä¼ é€’å¸¸é‡å¼•ç”¨çš„æƒ…å†µã€‚
        
        ```cpp
        #include <iostream>
        
        class MyClass {
        public:
            MyClass(int value) : value(value) {}
        
            void callExternalFunction() {
                // ä½¿ç”¨thisæŒ‡é’ˆè°ƒç”¨å¤–éƒ¨å‡½æ•°ï¼Œå¹¶ä¼ é€’å½“å‰å¯¹è±¡å®ä¾‹ä½œä¸ºå‚æ•°
                externalFunction(*this);
            }
        
            int getValue() const {
                return value;
            }
        
        private:
            int value;
        };
        
        // å¤–éƒ¨å‡½æ•°ï¼Œæ¥å—MyClasså¯¹è±¡çš„å¼•ç”¨ä½œä¸ºå‚æ•°
        void externalFunction(const MyClass& obj) {
            std::cout << "External function called with value: " << obj.getValue() << std::endl;
        }
        
        int main() {
            MyClass obj(42);
            obj.callExternalFunction();
        
            return 0;
        }
        ```
        
    - ğŸ“š ç‰¹æ®Šç”¨é€”ä¸æ³¨æ„äº‹é¡¹
        - æ¢è®¨äº†thisæŒ‡é’ˆçš„ä¸€äº›ç‰¹æ®Šç”¨é€”ï¼Œä¾‹å¦‚delete thisï¼Œå¼ºè°ƒäº†é¿å…ä½¿ç”¨è¿™ç§ç”¨æ³•çš„é‡è¦æ€§ã€‚
        - æç¤ºäº†é¿å…åœ¨æˆå‘˜å‡½æ•°ä¸­è°ƒç”¨delete thisçš„å±é™©ï¼Œä»¥åŠå»ºè®®é¿å…è¿™ç§åšæ³•çš„ç†ç”±ã€‚
        
        # Stack
        
        objects in stack can be destroyed automatically, but in heap, they canâ€™t. We can write a class to help us destroy ptr automatically
        
        ```cpp
        class ScopePtr
        {
        public:
        	ScopePtr(Entity* e);
        	~ScopePtr();
        
        private:
        	Entity* ePtr;
        };
        
        ScopePtr::ScopePtr(Entity* e) :ePtr(e)
        {
        }
        
        ScopePtr::~ScopePtr()
        {
        	delete ePtr;
        }
        ```
        
        # Smart Pointer
        
        Smart Pointer can help us allocate and release memory automatically, but we still should pay attention to some points.
        
        ## shared_ptr
        
        we should be careful about circular references. It can cause memory leak.
        
        like this:
        
        ```cpp
        #include <iostream>
        #include <memory>
        
        class Node {
        public:
            Node() { std::cout << "Node constructor" << std::endl; }
            ~Node() { std::cout << "Node destructor" << std::endl; }
        
            // æŒæœ‰å¯¹å¦ä¸€ä¸ªNodeçš„shared_ptr
            std::shared_ptr<Node> next;
        };
        
        int main() {
            std::shared_ptr<Node> node1 = std::make_shared<Node>();
            std::shared_ptr<Node> node2 = std::make_shared<Node>();
        
            // åˆ›å»ºå¾ªç¯å¼•ç”¨
            node1->next = node2;
            node2->next = node1;
        
            return 0;
        }
        ```
        
        ## weak_ptr
        
        we can use weak_ptr to test if the shared_ptr existed. Because weak_ptr donâ€™t increase the reference count.
        
        There is an example that using weak_ptr to check shared_ptr
        
        ```cpp
        #include <iostream>
        #include <memory>
        
        int main() {
            std::shared_ptr<int> sharedPtr = std::make_shared<int>(42);
            std::weak_ptr<int> weakPtr(sharedPtr);
        
            // å°è¯•å°† weak_ptr è½¬æ¢ä¸º shared_ptr
            if (auto shared = weakPtr.lock()) {
                std::cout << "Value from weak_ptr: " << *shared << std::endl;
            } else {
                std::cout << "Object no longer exists." << std::endl;
            }
        
            return 0;
        }
        ```
        
        # Vector
        
        vector is a dynamic array, it can expand its size dynamically. But we still need to pay attention to some points to optimize the usage of vector:
        
        1. we can declare the size we want to use.
           
            ```cpp
            std::vector<Vertex> vertextes(4);
            ```
            
        2. we can replace `push_back` by `emplace_back` 
           
            ```cpp
            vertextes.emplace_back(1,2,3);
            ```
            
        
        # work with Library
        
        dll: dynamic link library, dll is a library which link resource on runtime
        
        lib: static library, the reference just be put into the project, it will be linked when it is compiled.
        
        firstly, we need to config the path of the lib. `$(SolutionDir)` is prefixes for path
        
        ![Untitled](./c++/Untitled%208.png)
        
        # Return type from func
        
        In C++, you can return objects from functions just like you can return other data types. Here's an example of how to do it:
        
        ```cpp
        #include <iostream>
        #include <string>
        
        class MyClass {
        public:
            MyClass(const std::string& value) : data(value) {}
        
            void displayData() {
                std::cout << "Data: " << data << std::endl;
            }
        
        private:
            std::string data;
        };
        
        MyClass createObject(const std::string& value) {
            MyClass newObj(value);
            return newObj;
        }
        
        int main() {
            MyClass obj = createObject("Hello, World!");
            obj.displayData();
        
            return 0;
        }
        
        ```
        
        When a function returns an object, C++ uses a mechanism called Return Value Optimization (RVO) or Named Return Value Optimization (NRVO) to optimize the return process. These optimizations are intended to eliminate unnecessary object copying, so even though it looks like the object is being copied, in many cases, it's actually being optimized by the compiler to avoid the copy. This means that returning objects from functions is generally efficient and idiomatic in C++.
        
        ## whatâ€™s RVO and NRVO
        
        RVO and NRVO are two optimization methods used by c++ compiler. In order to eliminate unnecessary object copying.
        
        In RVO, the local object constructed directly in the memory location where the object is expected to be stored.
        
        NRVO is a specific case in RVO where the object in function has a name and compiler optimizes the return by reuse the same object when it can.
        
        ## how to return multiply variables from func
        
        There are many methods can return multiply variables, there is a good way to do it:
        
        ```cpp
        Student GetStudent()
        {
        	std::string str1 = "xjl";
        	std::string str2 = "male";
        	int age = 16;
        
        	Student std(str1, str2, age);
        	return std::move(std); //to eliminate unnecessary copying
        }
        
        int main()
        {
        	Student st = GetStudent();
        	std::cout << st.age << std::endl;
        }
        ```
        
        Also, we can use tuple to return variables in this case. Tuple is an ordered collection of variables. But itâ€™s inconvenient to get element in it. We must use `get<index>` , but we canâ€™t know what we get actually.
        
        ```cpp
        #include <tuple>
        
        std::tuple<std::string,std::string,int> MultiplyValueReturns()
        {
        	std::string str1 = "name";
        	std::string str2 = "gender";
        	int age = 26;
        
        	return std::make_tuple(str1, str2, age);
        }
        
        int main()
        {
        	auto result = MultiplyValueReturns();
        	std::cout << std::get<0>(result) << std::get<1>(result) << std::get<2>(result) << std::endl;
        }
        ```
        
        # template
        
        template likes Generic in C#, it is designed to work with different data types, the actual type is typically inferred from the argument when the function or class is used. 
        
        ```cpp
        template<typename T, int N>
        class ObjectPool
        {
        public:
        	ObjectPool() {};
        	~ObjectPool() {};
        	void GetMemberFromVector();
        	void InsertVector();
        
        private:
        	std::vector<T> vec;
        };
        
        template<typename T, int N>
        void ObjectPool<T, N>::GetMemberFromVector()
        {
        	for (int i = 0; i < N; i++)
        	{
        		std::cout << vec[i].age << std::endl;
        	}
        }
        
        template<typename T, int N>
        void ObjectPool<T, N>::InsertVector()
        {
        	for (int i = 0; i < N; i++)
        	{
        		vec.emplace_back("1", "male", 10+i);
        	}
        }
        
        int main()
        {
        	ObjectPool<Student,5> pool;
        	pool.InsertVector();
        	pool.GetMemberFromVector();
        }
        ```
        
        # Macros
        
        we can use macros to do some preprocess. And we also can define different preprocess for different model, such as debug and release.
        
        ![Untitled](./c++/Untitled%209.png)
        
        ![Untitled](./c++/Untitled%2010.png)
        
        ```cpp
        #ifdef R_DEBUG
        #define Log(x) std::cout<<x << std::endl
        #else
        #define Log(x)
        #endif // R_DEBUG
        ```
        
        # Callback in C++
        
        There are three ways to implement callback function, such as Function Pointer, Functor and Lambda expression.
        
        `Function Pointer`  points a memory location where the function is, there is example:
        
        ```cpp
        typedef void(*Callback)(int);
        void OnListener(int a)
        {
        	std::cout << "value is: " << a << std::endl;
        }
        
        void AddListener(Callback callback,int value)
        {
        	callback(value);
        }
        
        int main()
        {
        	AddListener(OnListener, 100);
        }
        ```
        
        `Functor` 
        
        ```cpp
        #include <iostream>
        
        // å›è°ƒå‡½æ•°å¯¹è±¡
        struct MyCallbackFunctor {
            void operator()(int value) {
                std::cout << "Callback called with value: " << value << std::endl;
            }
        };
        
        // ä½¿ç”¨å›è°ƒå‡½æ•°å¯¹è±¡çš„å‡½æ•°
        void DoSomethingWithCallback(int value, MyCallbackFunctor callback) {
            // åšä¸€äº›å·¥ä½œ
            callback(value); // è°ƒç”¨å›è°ƒå‡½æ•°å¯¹è±¡
        }
        
        int main() {
            MyCallbackFunctor functor;
            DoSomethingWithCallback(42, functor);
            return 0;
        }
        ```
        
        Lambda expression, `[]` capture variable which is outside of the function
        
        ```cpp
        #include <iostream>
        
        // ä½¿ç”¨ Lambda è¡¨è¾¾å¼çš„å‡½æ•°
        void DoSomethingWithCallback(int value, const std::function<void(int)>& callback) {
            // åšä¸€äº›å·¥ä½œ
            callback(value); // è°ƒç”¨ Lambda è¡¨è¾¾å¼
        }
        
        int main() {
            // ä½¿ç”¨ Lambda è¡¨è¾¾å¼ä½œä¸ºå›è°ƒ
            DoSomethingWithCallback(42, [](int value) {
                std::cout << "Callback called with value: " << value << std::endl;
            });
            return 0;
        }
        ```
        
        ## [ ] in lambda
        
        In C++ lambda expressions, the square brackets `[]` are used to capture variables from the surrounding scope. The choice of what to capture and how to capture it depends on your specific requirements. There are three main capture modes:
        
        1. **Capture by Value**: `[variable]`
            - This captures a specific variable by value, which means that a copy of the variable is stored in the lambda.
            - Modifications to the captured variable inside the lambda do not affect the original variable in the outer scope.
            
            ```cpp
            int x = 42;
            auto lambda = [x](){
                std::cout << x << std::endl; // x is captured by value
            };
            
            ```
            
        2. **Capture by Reference**: `[&variable]`
            - This captures a specific variable by reference, which means that the lambda operates on the original variable in the outer scope.
            - Modifications to the captured variable inside the lambda will affect the original variable.
            
            ```cpp
            int y = 42;
            auto lambda = [&y](){
                y = 100; // y is captured by reference
            };
            
            ```
            
        3. **Capture All Variables by Value or Reference**: `[=]` or `[&]`
            - `[=]` captures all variables used inside the lambda by value.
            - `[&]` captures all variables used inside the lambda by reference.
            
            ```cpp
            int a = 10, b = 20;
            auto lambda1 = [=](){
                std::cout << a + b << std::endl; // a and b are captured by value
            };
            auto lambda2 = [&](){
                a = 100; // a and b are captured by reference
            };
            
            ```
            
        
        You can also mix and match capture modes for different variables within the same lambda expression. For example:
        
        ```cpp
        int a = 10, b = 20;
        auto lambda = [a, &b](){
            std::cout << a + b << std::endl; // a is captured by value, b is captured by reference
        };
        
        ```
        
        The choice of how to capture variables depends on the specific use case and whether you want to modify the original variables within the lambda or not.
        
        ## why should we use static in member function
        
        when we use member function for callback,  we should pass `this`  as a hidden argument to the callback function, since we should get the context to use member variables. But pass pointer `this` will cost a lot of performance. We need try to avoid this situation. 
        
        Static function only has one instance in whole project, we just need to find the location in memory where instruction is and use it. So we donâ€™t need to pass pointer `this` 
        
        ```cpp
        #include <iostream>
        #include <functional>
        
        class CallbackHandler {
        public:
            void NonStaticCallback(int value) {
                std::cout << "Non-static callback called with value: " << value << std::endl;
            }
        };
        
        // ä½¿ç”¨ std::function ä½œä¸ºå›è°ƒå‡½æ•°çš„å®¹å™¨
        void UseCallback(int value, std::function<void(int)> callback) {
            callback(value);
        }
        
        int main() {
            CallbackHandler obj;
            
            // ä½¿ç”¨ std::function åŒ…è£…éé™æ€æˆå‘˜å‡½æ•°
            std::function<void(int)> callback = std::bind(&CallbackHandler::NonStaticCallback, &obj, std::placeholders::_1);
        
            // å°†åŒ…è£…åçš„å›è°ƒå‡½æ•°ä¼ é€’ç»™ä½¿ç”¨å›è°ƒçš„å‡½æ•°
            UseCallback(42, callback);
            
            return 0;
        }
        ```
        
        # why not use namespace std
        
        <aside>
        ğŸ’¡ Never use namespace std on the head file!!!!
        
        </aside>
        
        and we need to know what we had used.
        
        # Thread
        
        Understanding how to use C++'s multithreading library and best practices in multithreaded programming is crucial. Below, I'll provide a brief overview of multithreading in C++ and provide examples to illustrate its applications.
        
        ### Multithreading in C++
        
        C++11 introduced multithreading support, which includes the `std::thread` class and other tools and features related to multithreading. With C++ multithreading, you can create, manage, and synchronize multiple threads to execute tasks in parallel or concurrently. Here are some key concepts in C++ multithreading:
        
        1. **`std::thread` Class**: `std::thread` is the C++ class used to create threads. You can use it to create new threads and run functions or callable objects.
           
            ```cpp
            #include <iostream>
            #include <thread>
            
            void threadFunction() {
                std::cout << "Hello from the new thread!" << std::endl;
            }
            
            int main() {
                std::thread t(threadFunction);
                t.join(); // Wait for the thread to finish
                std::cout << "Back in the main thread." << std::endl;
                return 0;
            }
            
            ```
            
        2. **Thread Synchronization**: Multithreaded programming can lead to race conditions and data races. C++ provides tools like mutexes (`std::mutex`) and condition variables (`std::condition_variable`) to help ensure thread safety.
           
            ```cpp
            #include <iostream>
            #include <thread>
            #include <mutex>
            
            std::mutex mtx;
            
            void threadFunction(int &counter) {
                for (int i = 0; i < 1000; ++i) {
                    std::lock_guard<std::mutex> lock(mtx);
                    counter++;
                }
            }
            
            int main() {
                int counter = 0;
                std::thread t1(threadFunction, std::ref(counter));
                std::thread t2(threadFunction, std::ref(counter));
            
                t1.join();
                t2.join();
            
                std::cout << "Counter: " << counter << std::endl;
                return 0;
            }
            
            ```
            
        3. **Parallel Computing**: C++ multithreading can be used to parallelize compute tasks, speeding up the processing of large data sets or compute-intensive tasks. For example, you can use `std::async` to launch asynchronous tasks.
           
            ```cpp
            #include <iostream>
            #include <vector>
            #include <future>
            
            int square(int x) {
                return x * x;
            }
            
            int main() {
                std::vector<std::future<int>> futures;
                for (int i = 0; i < 10; ++i) {
                    futures.push_back(std::async(std::launch::async, square, i));
                }
            
                for (auto &f : futures) {
                    std::cout << "Result: " << f.get() << std::endl;
                }
            
                return 0;
            }
            
            ```
            
        4. **Deadlocks and Performance Optimization**: Multithreaded programming requires careful handling of deadlocks and performance optimization. Understanding how to design multithreaded applications to avoid deadlocks and optimize performance is important.
        
        ### Example: Multithreaded Image Processing
        
        Suppose you need to process a large number of images, such as resizing and saving them. Using multithreading can significantly speed up the processing. Here's a simple example of multithreaded image processing using C++'s multithreading library:
        
        ```cpp
        #include <iostream>
        #include <thread>
        #include <vector>
        
        void processImage(const std::string &filename) {
            // Perform image processing
            std::cout << "Processing image: " << filename << std::endl;
            // Image processing code is omitted here
        }
        
        int main() {
            std::vector<std::string> imageFiles = {"image1.jpg", "image2.jpg", "image3.jpg", /*...*/};
            std::vector<std::thread> threads;
        
            for (const std::string &filename : imageFiles) {
                threads.push_back(std::thread(processImage, filename));
            }
        
            for (std::thread &t : threads) {
                t.join();
            }
        
            std::cout << "All images processed." << std::endl;
        
            return 0;
        }
        
        ```
        
        In this example, each image processing task is assigned to an independent thread, allowing multiple images to be processed simultaneously, thereby improving processing speed.
        
        In summary, C++ multithreading is a powerful tool for handling parallel and concurrent tasks. Using `std::thread`, thread synchronization mechanisms, and other related tools, you can harness the performance potential of multi-core processors. However, multithreaded programming requires careful handling of concurrency issues to avoid race conditions and deadlocks.
        
        # Timer
        
        ```cpp
        struct Timer
        {
        	std::chrono::time_point<std::chrono::steady_clock> begin, end;
        	std::chrono::duration<float> duration;
        
        	Timer()
        	{
        		begin = std::chrono::high_resolution_clock::now();
        	}
        
        	~Timer()
        	{
        		end = std::chrono::high_resolution_clock::now();
        		duration = end - begin;
        
        		auto dur = duration.count() * 1000.0f;
        		std::cout << "duration: " << dur << "ms" << std::endl;
        	}
        };
        ```
        
        Timer can be used for record time span.
        
        # 2d array
        
        build a normal 2d array is slow, since we should foreach every time.
        
        ```cpp
        //this way to build a 2d array is slow
        int** a2d = new int* [5];
        
        for (int i = 0; i < 5; i++)
        {
        	a2d[i] = new int[5];
        	for (int j = 0; j < 5; j++)
        	{
        		a2d[i][j] = 2;
        	}
        }
        
        std::cout << a2d[1][2] << std::endl;
        ```
        
        this way is fast
        
        ```cpp
        //this way is faster
        int* arr = new int[5 * 5];
        for (int i = 0; i < 5; i++)
        {
        	for (int j = 0; j < 5; j++)
        	{
        		arr[j + i * 5] = 2;
        	}
        }
        
        std::cout << arr[2+1*5] << std::endl;
        ```
        
        # Type running in c++
        
        ```cpp
        struct Entity
        {
        	int x,y;
        }
        
        int main()
        {
        	Entity e = {5,8};
        	int* position = (int*)&e; // type cast
        	std::cout << position << std::endl;
        }
        ```
        
        # Union
        
        union is a special type which can give different data types same memory spaces. Itâ€™s similar to a  struct in that it can contain different type, but only one member can contain a value at any given time. The size of the value is taken the largest member.
        
        ```cpp
        #include<iostream>
        using namespace std;
        
        union myUnion {
            int myInt;
            float myFloat;
            char myChar;
        };
        
        int main() {
            myUnion testUnion;
            testUnion.myInt = 3;
            cout << "myInt: " << testUnion.myInt << endl;
            
            testUnion.myFloat = 4.5;
            // Note: The value of myInt is undefined after assigning to myFloat
            cout << "myFloat: " << testUnion.myFloat << endl;
            
            testUnion.myChar = 'a';
            // Note: The value of myFloat and myInt is undefined after assigning to myChar
            cout << "myChar: " << testUnion.myChar << endl;
        		std::cout << "myInt: " << testUnion.myInt << std::endl;
        		std::cout << "myFloat: " << testUnion.myFloat << std::endl;
            
            return 0;
        }
        ```
        
        In the example above, **`myUnion`** is a union that can hold an **`int`**, a **`float`**, or a **`char`**. However, it can only hold one of these types at a time. When we assign a value to **`myFloat`**, the content of **`myInt`** becomes undefined because they share the `same memory location`. The same happens when we assign a value to **`myChar`**.
        
        Unions are useful in situations where you want to use the same memory space for different types, and you are sure about which type is stored in the union at any point in time. This can lead to more memory-efficient programs.
        
        For example: if we want to store data struct in one memory location, such as tcp and udp, if we use union, we don't need shift bits, it can be quicker and safer.
        
        # condition and action breakpoint
        
        ![Untitled](./c++/Untitled%2011.png)
        
        # Casting in c++
        
        ## static cast
        
        static cast only performs conversion between compatible types. such as int, double, float
        
        ```cpp
        int a = 10;
        double b = static_cast<double>(a);
        std::cout << b << std::endl;
        b = 2.333;
        int c = static_cast<int>(b);
        std::cout << c << std::endl;
        ```
        
        ## dynamic cast
        
        dynamic cast is handling for polymorphism, we can use dynamic cast to downcast safely. It requires at least one of the classes in the hierarchy have a virtual function.
        
        ```cpp
        class Student
        {
        private:
        	int age;
        	std::string name;
        public:
        	virtual void Func() {}
        };
        
        class Undergradudate: public Student
        {
        	bool male;
        };
        
        int main()
        {
        	Student* stu = new Undergradudate();
        	Undergradudate* unStu = dynamic_cast<Undergradudate*>(stu);
        }
        ```
        
        ## const cast
        
        const cast is always used to eliminate cast, and the type in the const_cast must be a pointer or reference.
        
        ```cpp
        const int* f = new int(10);
        int* h = const_cast<int*>(f);
        ```
        
        ## reinterpret cast
        
        it can convert any types of pointer to any  other types of pointers, itâ€™s unsafe
        
        ### **Best Practices:**
        
        - Prefer C++-style casts over C-style casts.
        - Use **`static_cast`** when you are converting between related types.
        - Use **`dynamic_cast`** for safely downcasting with polymorphic types.
        - Avoid using **`reinterpret_cast`** unless absolutely necessary.
        - Avoid using **`const_cast`**; reconsider your programâ€™s design if you find yourself needing it frequently.
        - Avoid C-style and function-style casts for safer and more readable code.
    
    # Precompiled Headers
    
    - What is a precompiled header file: A precompiled header file can convert a set of header files into a format that the compiler can use directly, reducing compilation time.
    - ğŸš€ Benefits of using precompiled header files: Significantly improves compilation speed, especially in large projects.
    - ğŸ›‘ Do not put frequently modified files into the precompiled header file to avoid repeated recompilation.
    - ğŸŒ Best practices for using precompiled header files: Put infrequently modified and highly dependent files into the precompiled header file, such as standard library files and third-party library files.
    - ğŸ›  How to set up and use precompiled header files in Visual Studio and GCC.
    - ğŸ“ˆ The importance of precompiled header files in improving compilation efficiency.
    - â“ Points to note when using precompiled header files, and how to avoid potential problems.
    - ğŸ¯ Conclusion and a call to the audience to start using precompiled header files to enhance their development efficiency.
    
    # Structure Binding
    
    In c++17, we can use structure binding to accept the return from a func.
    
    ```cpp
    std::tuple<std::string, int> CreatePerson()
    {
    	return { "Russell",26 };
    }
    
    int main()
    {
    	auto[name, age] = CreatePerson();
    	std::cout << name << "," << age << std::endl;
    }
    ```
    
    # std::optional
    
    `std::optional` is a feature introduced in C++17 that provides a way to represent optional values, which can be especially useful when a function may or may not return a valid result. `std::optional` can be thought of as a type-safe, better alternative to using raw pointers or special sentinel values to indicate the absence of a value.
    
    Here is a quick summary and example of how to use `std::optional`:
    
    ### Including the Header
    
    To use `std::optional`, you need to include the header:
    
    ```cpp
    #include <optional>
    
    ```
    
    ### Basic Usage
    
    You can create an `std::optional` object like this:
    
    ```cpp
    std::optional<int> maybeNumber;
    
    ```
    
    This creates an optional that doesnâ€™t contain a value. You can check if it contains a value using the `has_value()` member function or the `operator bool()`:
    
    ```cpp
    if (maybeNumber) {
        std::cout << "The number is " << maybeNumber.value() << '\\n';
    } else {
        std::cout << "The number is not set.\\n";
    }
    
    ```
    
    You can assign a value to it like this:
    
    ```cpp
    maybeNumber = 42;
    
    ```
    
    And you can retrieve the value using the `value()` function, but be careful â€“ calling `value()` on an empty `std::optional` will throw a `std::bad_optional_access` exception:
    
    ```cpp
    int number = maybeNumber.value();  // OK, maybeNumber contains a value
    
    ```
    
    Alternatively, you can use `value_or(default_value)` to retrieve the value or a default if itâ€™s not set:
    
    ```cpp
    int number = maybeNumber.value_or(0);  // Returns 0 if maybeNumber is empty
    
    ```
    
    ### Creating Optional from a Function
    
    You can use `std::optional` as a return type for functions that may or may not produce a result:
    
    ```cpp
    std::optional<int> findNumber(const std::vector<int>& numbers, int toFind) {
        for (int number : numbers) {
            if (number == toFind) {
                return number;  // Found, return the number
            }
        }
        return {};  // Not found, return an empty optional
    }
    
    ```
    
    Usage:
    
    ```cpp
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    auto result = findNumber(numbers, 3);
    if (result) {
        std::cout << "Number found: " << result.value() << '\\n';
    } else {
        std::cout << "Number not found.\\n";
    }
    
    ```
    
    ### In Place Construction
    
    You can also construct the value in place:
    
    ```cpp
    std::optional<std::string> maybeString(std::in_place, "Hello, World!");
    
    ```
    
    ### Resetting an Optional
    
    To clear the value of an optional, you can use the `reset()` function:
    
    ```cpp
    maybeNumber.reset();  // Clears the value
    
    ```
    
    ### Summary
    
    `std::optional` is a powerful tool in C++17 that helps to express the notion of an optional value in a type-safe manner. It helps to avoid using raw pointers or special sentinel values, making code safer and more expressive.
    
    # Variant
    
    `std::variant` is a feature introduced in C++17 that provides a type-safe way to store and manipulate values of different types. It can be thought of as a safer, more expressive alternative to a union.
    
    A `std::variant` can hold a value of one of the specified types, and it always holds a value (it's never empty, unless it holds a type that can be empty).
    
    Here's a quick guide and example of how to use `std::variant`:
    
    ### Including the Header
    
    To use `std::variant`, you need to include the header:
    
    ```cpp
    #include <variant>
    
    ```
    
    ### Basic Usage
    
    You can create a `std::variant` object by specifying the types it can hold:
    
    ```cpp
    std::variant<int, float, std::string> v;
    
    ```
    
    This creates a variant that can hold an `int`, a `float`, or a `std::string`. Initially, it holds a value of the first specified type (`int` in this case).
    
    You can assign values of the specified types:
    
    ```cpp
    v = 10;         // v holds an int
    v = 3.14f;      // v holds a float
    v = "Hello";    // v holds a std::string
    
    ```
    
    ### Visiting the Value
    
    To access the value in a type-safe manner, you can use `std::visit`:
    
    ```cpp
    std::visit([](auto&& arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, int>) {
            std::cout << "int with value " << arg << '\\n';
        } else if constexpr (std::is_same_v<T, float>) {
            std::cout << "float with value " << arg << '\\n';
        } else if constexpr (std::is_same_v<T, std::string>) {
            std::cout << "std::string with value " << arg << '\\n';
        }
    }, v);
    
    ```
    
    ### Checking the Type
    
    You can check the currently held type using `std::holds_alternative`:
    
    ```cpp
    if (std::holds_alternative<int>(v)) {
        std::cout << "The variant holds an int.\\n";
    } else if (std::holds_alternative<float>(v)) {
        std::cout << "The variant holds a float.\\n";
    } else if (std::holds_alternative<std::string>(v)) {
        std::cout << "The variant holds a std::string.\\n";
    }
    
    ```
    
    ### Accessing the Value Directly
    
    You can also access the value directly using `std::get`, but be careful â€“ if you use `std::get` with a type that the variant doesnâ€™t currently hold, an exception (`std::bad_variant_access`) will be thrown:
    
    ```cpp
    try {
        int i = std::get<int>(v);  // OK if v holds an int
    } catch (const std::bad_variant_access& e) {
        std::cerr << "Error: " << e.what() << '\\n';
    }
    
    ```
    
    You can also use `std::get_if` to access the value safely:
    
    ```cpp
    if (auto ptr = std::get_if<int>(&v)) {
        std::cout << "The variant holds an int with value " << *ptr << '\\n';
    } else {
        std::cout << "The variant does not hold an int.\\n";
    }
    
    ```
    
    ### Summary
    
    `std::variant` is a powerful and type-safe way to work with values of different types. It is a safer alternative to unions and provides more expressive ways to manipulate and access the values. The combination of `std::variant`, `std::visit`, and `std::get` provides a robust way to work with heterogeneous types in a type-safe manner.
    
    # any
    
    `std::any`æ˜¯C++17ä¸­å¼•å…¥çš„ä¸€ç§ç±»å‹ï¼Œå¯ä»¥ç”¨æ¥å­˜å‚¨ä»»ä½•ç±»å‹çš„å€¼ã€‚`std::any`çš„å®ç°é€šå¸¸ä½¿ç”¨äº†ä¸€ç§å«åšâ€œå°å¯¹è±¡ä¼˜åŒ–â€ï¼ˆSmall Object Optimization, SSOï¼‰çš„æŠ€æœ¯ï¼Œè¿™ç§æŠ€æœ¯èƒ½å¤Ÿåœ¨å¯¹è±¡è¾ƒå°çš„æƒ…å†µä¸‹é¿å…åŠ¨æ€å†…å­˜åˆ†é…ã€‚
    
    å…·ä½“æ¥è¯´ï¼Œ`std::any`ä¼šåœ¨`æ ˆä¸Š`é¢„ç•™ä¸€å°å—å†…å­˜ï¼Œç”¨äºå­˜å‚¨å°çš„å¯¹è±¡ã€‚å¦‚æœå­˜å‚¨çš„å¯¹è±¡å¤§å°è¶…è¿‡è¿™ä¸ªé¢„ç•™çš„å†…å­˜å¤§å°ï¼Œ`std::any`ä¼šè¿›è¡ŒåŠ¨æ€å†…å­˜åˆ†é…æ¥å­˜å‚¨å¯¹è±¡ã€‚
    
    æ‰€ä»¥ï¼Œå¯¹äºå°å‹æ•°æ®ï¼Œ`std::any`é€šå¸¸ä¸ä¼šè¿›è¡ŒåŠ¨æ€å†…å­˜åˆ†é…ï¼Œè€Œæ˜¯ç›´æ¥åœ¨æ ˆä¸Šå­˜å‚¨æ•°æ®ã€‚å¯¹äºå¤§å‹æ•°æ®ï¼Œ`std::any`ä¼šè¿›è¡ŒåŠ¨æ€å†…å­˜åˆ†é…ã€‚
    
    è¿™é‡Œæœ‰ä¸ªç®€å•çš„ä¾‹å­æ¥è¯´æ˜è¿™ä¸€ç‚¹ï¼š
    
    ```cpp
    #include <any>
    #include <iostream>
    #include <vector>
    
    int main() {
        std::any smallData = 42;  // å°å¯¹è±¡ï¼Œå­˜å‚¨åœ¨æ ˆä¸Š
        std::any largeData = std::vector<int>(1000, 42);  // å¤§å¯¹è±¡ï¼Œå¯èƒ½è¿›è¡ŒåŠ¨æ€å†…å­˜åˆ†é…
    
        std::cout << "Done\\n";
        return 0;
    }
    
    ```
    
    åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`smallData`å­˜å‚¨äº†ä¸€ä¸ªintç±»å‹çš„å¯¹è±¡ï¼Œå®ƒæ˜¯ä¸€ä¸ªå°å¯¹è±¡ï¼Œé€šå¸¸ä¼šç›´æ¥å­˜å‚¨åœ¨`std::any`å†…éƒ¨çš„é¢„ç•™ç©ºé—´ä¸­ï¼Œä¸ä¼šè¿›è¡ŒåŠ¨æ€å†…å­˜åˆ†é…ã€‚è€Œ`largeData`å­˜å‚¨äº†ä¸€ä¸ª`std::vector<int>`å¯¹è±¡ï¼Œå®ƒæ˜¯ä¸€ä¸ªå¤§å¯¹è±¡ï¼Œå¯èƒ½ä¼šå¯¼è‡´`std::any`è¿›è¡ŒåŠ¨æ€å†…å­˜åˆ†é…ã€‚
    
    å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå…·ä½“å¤šå¤§çš„å¯¹è±¡ä¼šè§¦å‘åŠ¨æ€å†…å­˜åˆ†é…å–å†³äº`std::any`çš„å®ç°å’Œå¹³å°çš„å…·ä½“æƒ…å†µã€‚C++æ ‡å‡†å¹¶æ²¡æœ‰è§„å®š`std::any`å¿…é¡»ä½¿ç”¨å°å¯¹è±¡ä¼˜åŒ–ï¼Œä¹Ÿæ²¡æœ‰è§„å®šé¢„ç•™å¤šå°‘å†…å­˜ç»™å°å¯¹è±¡ã€‚æ‰€ä»¥ä¸åŒçš„ç¼–è¯‘å™¨å’Œå¹³å°å¯èƒ½ä¼šæœ‰ä¸åŒçš„è¡Œä¸ºã€‚
    
    # String_view
    
    **`std::string_view`**æ˜¯C++17ä¸­å¼•å…¥çš„ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„ç±»æ¨¡æ¿ã€‚å®ƒä¸ºå­—ç¬¦æ•°ç»„ï¼ˆé€šå¸¸æ˜¯**`std::string`**æˆ–å­—ç¬¦æ•°ç»„ï¼‰æä¾›äº†ä¸€ä¸ªè½»é‡çº§ã€ä¸æ‹¥æœ‰çš„è§†å›¾ã€‚è¿™æ„å‘³ç€**`std::string_view`**æœ¬èº«å¹¶ä¸å­˜å‚¨å­—ç¬¦æ•°æ®ï¼Œè€Œåªæ˜¯æŒæœ‰å¯¹ç°æœ‰å­—ç¬¦æ•°æ®çš„å¼•ç”¨ï¼ˆé€šè¿‡ä¸€ä¸ªæŒ‡é’ˆå’Œä¸€ä¸ªé•¿åº¦ï¼‰ã€‚
    
    ä»¥ä¸‹æ˜¯**`std::string_view`**çš„ä¸€äº›å…³é”®ç‚¹å’Œä¼˜åŠ¿ï¼š
    
    1. **æ€§èƒ½ä¼˜åŒ–**ï¼šå®ƒå…è®¸å‡½æ•°æ¥å—ä»»ä½•ç±»å‹çš„å­—ç¬¦ä¸²æ•°æ®ï¼ˆ**`const char*`**, **`std::string`**, å­—ç¬¦æ•°ç»„ç­‰ï¼‰è€Œä¸éœ€è¦è¿›è¡Œé¢å¤–çš„å†…å­˜åˆ†é…æˆ–å¤åˆ¶ã€‚
    2. **å­å­—ç¬¦ä¸²æ“ä½œ**ï¼šä½¿ç”¨**`std::string_view`**å¯ä»¥è½»æ¾åœ°ã€æ— éœ€åˆ†é…é¢å¤–å†…å­˜åœ°è·å¾—å­—ç¬¦ä¸²çš„å­å­—ç¬¦ä¸²ã€‚
    3. **ä¸å…¶ä»–å­—ç¬¦ä¸²ç±»å‹å…¼å®¹**ï¼šä½ å¯ä»¥ä½¿ç”¨**`std::string_view`**ä½œä¸ºå‡½æ•°çš„å‚æ•°ç±»å‹ï¼Œè¿™æ ·è¯¥å‡½æ•°å°±å¯ä»¥æ¥å—**`std::string`**ã€å­—ç¬¦æ•°ç»„æˆ–**`const char*`**ä½œä¸ºå‚æ•°ï¼Œæ— éœ€è¿›è¡Œé¢å¤–çš„ç±»å‹è½¬æ¢ã€‚
    4. **ä¸æ‹¥æœ‰æ•°æ®**ï¼šéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ**`std::string_view`**å¹¶ä¸æ‹¥æœ‰å®ƒå¼•ç”¨çš„æ•°æ®ã€‚å¦‚æœåŸå§‹æ•°æ®è¢«é”€æ¯æˆ–è¶…å‡ºä½œç”¨åŸŸï¼Œè€Œ**`std::string_view`**ä»ç„¶å­˜åœ¨å¹¶å°è¯•è®¿é—®æ•°æ®ï¼Œé‚£ä¹ˆä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚
    5. **çµæ´»æ€§**ï¼š**`std::string_view`**å¯ä»¥è½»æ¾åœ°è½¬æ¢ä¸º**`std::string`**ï¼Œå¹¶æä¾›äº†**`std::string`**çš„è®¸å¤šå¸¸ç”¨æˆå‘˜å‡½æ•°ï¼Œå¦‚**`find`**, **`substr`**ç­‰ã€‚
    
    ## Small optimization in string
    
    in c++17, if you assign a short string (less than 15 bytes), there wonâ€™t be allocated.
    
    in c++ string, we can see the code, it judges the size of the string, if it is shorter than `_Mypair`, it will use an old buffer to store it.
    
    ![Untitled](./c++/Untitled%2012.png)
    
    we can have an experiment:
    
    in release:
    
    ```cpp
    void* operator new(size_t size)
    {
    	std::cout << "Allocating" << std::endl;
    	return malloc(size);
    }
    
    int main()
    {
    	std::string name = "Russell";
    }
    ```
    
    ![Untitled](./c++/Untitled%2013.png)
    
    there are no any allocate.
    
    ```cpp
    std::string name = "Russell asdasd asdasda asdasda dasdass";
    ```
    
    ![Untitled](./c++/Untitled%2014.png)
    
    there is an allocate
    
    # Singleton in C++
    
    Singleton is a design pattern, in c++ , it used as like namespace. it can organize stuff in a class, but it just like a namespace. But there is still a  different between them. **Singleton is based on keyword â€œstaticâ€, this can make there is only one instance of Singleton class in whole project.**
    
    ```cpp
    class Singleton
    {
    public:
    	Singleton(const Singleton&) = delete;
    
    	static Singleton& Get()
    	{
    		static Singleton Instance;
    		return Instance;
    	}
    
    	void PrintHelloWorld();
    
    private:
    	Singleton() {};
    };
    
    void Singleton::PrintHelloWorld()
    {
    	std::cout << "Hello World" << std::endl;
    }
    
    ```
    
    actually a namespace also can achieve the function same as singleton , but it is more organized.
    
    ```cpp
    namespace Singleton
    {
    	void PrintHelloWorld()
    	{
    
    	}
    }
    ```
    
    # Memory Tracker
    
    design own memory tracker by overload operator new and delete.
    
    ```cpp
    struct TrackMemrory
    {
    	uint32_t TotalAllocated = 0;
    	uint32_t TotalFreed = 0;
    };
    
    static TrackMemrory _trackMemory;
    
    void* operator new(size_t size)
    {
    	_trackMemory.TotalAllocated += size;
    	return malloc(size);
    }
    
    void operator delete(void* memory, size_t size)
    {
    	_trackMemory.TotalFreed += size;
    	free(memory);
    }
    
    void PrintMemoryTrack()
    {
    	std::cout << _trackMemory.TotalAllocated << " and" << _trackMemory.TotalFreed << std::endl;
    }
    
    int main()
    {
    	PrintMemoryTrack();
    	{
    		std::string name = "Russell asdasd asdasda asdasda dasdass";
    	}
    	PrintMemoryTrack();
    }
    ```
    
    ![Untitled](./c++/Untitled%2015.png)
    
    # lValue & RValue
    
    In C++, `lvalue` (left value) and `rvalue` (right value) are two main categories of expressions that describe the storage and identity characteristics of objects in memory.
    
    ### lvalue (left value)
    
    **Definition**: An `lvalue` refers to an expression that represents an object with a persistent state. In other words, an `lvalue` persists beyond the life of the expression, having a defined location in memory.
    
    **Characteristics**:
    
    - Can appear on the left-hand side of an assignment statement.
    - They represent objects or functions with a persistent address.
    - Typically can be referenced (you can take their address).
    
    **Examples**:
    
    ```cpp
    int x = 10;  // x is an lvalue
    int& ref = x; // ref is a reference to x, x must be an lvalue
    
    // Function returns a reference, hence an lvalue
    int& GetRef() {
        static int y = 10;
        return y;
    }
    
    GetRef() = 5; // OK, because GetRef returns an lvalue reference
    
    ```
    
    In this example, both `x` and `y` returned through `GetRef` are `lvalues` because they have a fixed position in memory.
    
    ### rvalue (right value)
    
    **Definition**: An `rvalue` refers to an expression that does not represent an object with a persistent state and usually represents temporary values that are not needed after their immediate use.
    
    **Characteristics**:
    
    - Cannot appear on the left-hand side of an assignment statement.
    - They are typically not referenceable (cannot directly take their address).
    - Often used to represent literals or expressions that return temporary objects.
    
    **Examples**:
    
    ```cpp
    int GetNumber() {
        return 42; // The returned 42 is an rvalue
    }
    
    int main() {
        int a = GetNumber(); // GetNumber() returns an rvalue
    
        int b = a + 2; // a + 2 yields an rvalue
    
        int&& rref = GetNumber(); // rref is a right value reference bound to an rvalue
    }
    
    ```
    
    In this example, the `42` returned by `GetNumber()` is an `rvalue` because it is a temporary value that does not require persistent storage. Similarly, the expression `a + 2` yields an `rvalue` because the result is temporary and does not have a fixed memory address.
    
    ### Lvalue References and Rvalue References
    
    C++11 introduced the concept of rvalue references, denoted with `&&`, which are particularly suited for managing temporary objects. They allow developers to safely move data from temporary objects, which is foundational for implementing move semantics and perfect forwarding.
    
    ```cpp
    void ProcessValue(int& lvalue) {
        std::cout << "LValue processed: " << lvalue << std::endl;
    }
    
    void ProcessValue(int&& rvalue) {
        std::cout << "RValue processed: " << rvalue << std::endl;
    }
    
    int main() {
        int x = 10;  // x is an lvalue
        ProcessValue(x); // Calls ProcessValue(int& lvalue)
        ProcessValue(20); // 20 is an rvalue, calls ProcessValue(int&& rvalue)
    }
    
    ```
    
    In this example, `x` is an `lvalue`, while the literal `20` is an `rvalue`.
    
    In summary, `lvalue` represents an object with a definite storage location, whereas `rvalue` represents a temporary or unnamed value that cannot be accessed directly via an identifier. Understanding the distinction between `lvalue` and `rvalue` is crucial for mastering advanced features in C++, such as move semantics and perfect forwarding.
    
    # C++ Tools
    
    Jenkins  -  continues integrations tool
    
    PVS-Studio - check semantic
    
    ReSharper C++
    
    # Move Constructor
    
    In C++, a move constructor and a move assignment operator were introduced in C++11. They allow the transfer of resources between objects without the expensive copy operations. This is particularly useful for managing dynamically allocated resources, such as memory, as it can significantly improve performance.
    
    The definition of a move constructor is as follows:
    
    ```cpp
    ClassName(ClassName&& other) noexcept {
        // Implement resource transfer here, typically involving swapping pointers
    }
    
    ```
    
    In the code above, `ClassName` is your class name, `&&` denotes an rvalue reference, and `other` is the object being moved.
    
    Here's an example demonstrating how to write a move constructor and how to use it:
    
    ```cpp
    #include <iostream>
    
    class MyString {
    private:
        char* data;
    
    public:
        // Constructor
        MyString(const char* str) {
            // Allocate memory and copy the string
            data = new char[strlen(str) + 1];
            strcpy(data, str);
        }
    
        // Move constructor
        MyString(MyString&& other) noexcept {
            // Transfer resources directly without copying
            data = other.data;
            other.data = nullptr;
        }
    
        // Destructor
        ~MyString() {
            delete[] data;
        }
    
        // Other member functions and operator overloads
    
        // Display the string
        void display() const {
            std::cout << data << std::endl;
        }
    };
    
    int main() {
        MyString str1("Hello");
        MyString str2(std::move(str1)); // Use the move constructor to transfer resources
        str1.display(); // Output is empty because the resources have been moved
        str2.display(); // Output is "Hello"
    
        return 0;
    }
    
    ```
    

# Make a data structure in C++

here we build a array with dynamic allocate. Using template can help us to assign typename and size dynamicly.

```cpp
template<typename T, size_t S>
class Array
{
public:
	constexpr size_t Size() const { return S; }
	T& operator[](size_t index) { return m_Data[index]; }
	const T& operator[](size_t index) const { return m_Data[index]; }
	T* Data() { return m_Data; }
private:
	T m_Data[S];
};

int main()
{
	int size = 5;
	Array<int, 5> arr;

	arr[1] = 2;
	const Array<int, 5> arrReference = arr;
	//note that memset() set size in memory, so we should give the sum of the size for whole memory. 
	memset(arr.Data(), 0, arr.Size() * sizeof(int));
	for (int i = 0; i < arr.Size(); i++)
	{
		std::cout << arr[i] << std::endl;
	}
}
```

# c++ Iterator

Iterator works like pointer, it overloads â€˜++â€™, â€˜- - â€˜, â€˜*â€™, â€˜â†’â€™ operators, this can help iterator point to elements step by step.

```cpp
for(auto& it=vec.begin(); it!=vec.End(); it++)
{
		std::cout << *it << std::endl; //dereference
}
```